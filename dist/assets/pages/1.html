<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel='stylesheet' href='../../main.css'>
</head>

<body>
  <div class="container-lesson">
    <h1>Алгоритм Грэхема</h1>
    <div class="card-panel">
      <h6>Требуемые знания</h6>
      <div class="chip">Стек</div>
      <div class="chip">Quicksort</div>
      <div class="chip">Вектора</div>
      <div class="chip">Полярные углы</div>
    </div>
    <div class="video-container z-depth-3">
      <iframe src="//www.youtube.com/embed/xtJARPikkuU?rel=0" frameborder="0" allowfullscreen></iframe>
    </div>
    <p>
      <h5>На данном уроке будет рассмотрено построение выпуклой оболочки для множества точек на плоскости.</h5>
      <object type="image/svg+xml" data="assets/svg/p0.svg"></object>

      <br>
      Для начала определим что это такое.

      <blockquote>
        Выпуклой оболочкой множества точек X будет такой минимальный по размеру выпуклый многоугольник, что все точки из
        X лежат внутри или на границах этого многоугольника, а его вершины принадлежат X.
      </blockquote>

      <h5>Теперь перейдем к ее построению.</h5>
      <blockquote>
        Выпуклый многоугольник - фигура, все точки которой лежат по одну сторону от любой прямой, проходящей
        через любые две его соседние вершины.
      </blockquote>

      Из этого опредедения можно вывести способ проверки точки на принадлежность выпуклой оболочке - поворот между
      входящим
      в оболочку ребром и следующим должен быть не правым, но угол должен быть наибольшим, чтобы не взять точки внутри
      оболочки.

      <br>

      $p2
      <ul class="collapsible">
        <li>
          <div class="collapsible-header"><i class="material-icons">filter_drama</i>First</div>
          <div class="collapsible-body"><span>Lorem ipsum dolor sit amet.</span></div>
        </li>
        <li>
          <div class="collapsible-header"><i class="material-icons">place</i>Second</div>
          <div class="collapsible-body"><span>Lorem ipsum dolor sit amet.</span></div>
        </li>
        <li>
          <div class="collapsible-header"><i class="material-icons">whatshot</i>Third</div>
          <div class="collapsible-body"><span>Lorem ipsum dolor sit amet.</span></div>
        </li>
      </ul>
      <h6>В данном уроке будет рассмотрен алгоритм Грэхема, состоящий из 3х шагов</h6>

      Первый шаг - поиск первой точки, гарантированно входящей в искомую оболочку. За такую, например, возьмем точку с
      наименьшей y-координатой. Сделаем ее нулевым элементом нашего списка.

      $p3

      Далее сортируем все точки по предикату поворота, также известному как ориентированная площадь треугольника. Это
      отдельная тема, подробно она рассмотрена в другом уроке. Для нас это просто функция angle(a, b, c) = ***
      Подойдет любая сортировка основанная на сравнении пары элементов. В нашем случае компаратором выступит угол
      между
      векторами (A[0]; B) и (A[0]; C), тогда будем считать, что B > C, когда точка C находится по правую сторону от
      вектора
      (A[0]; B)
      $p7
      $p4

      После чего соединим последовательно отсортированные точки, в результате чего получим некиймногоугольник, который
      все
      еще
      не является выпуклым

      $p8

      Далее потребуется удалить те точки, после которых происходит правый поворот, т.к. они и нарушают выпуклость
      искомой
      оболочки.
      Для этого заводим стек, содержащий первые 2 вершины нового списка, исходя из того, что они гарантированно
      принадлежат
      оболочке.
      Далее идем по оставшимся, проверяя направление поворота каждой следующей точки отностительно вектора предыдущих
      2х
      из
      стека. Важно заметить, что это делается не один раз, а пока такие точки не закончатся сверху нашего стека. В
      случае
      правого поворота удаляем последнюю точку. После проверки добавим новую точку в стек.

      $a0

      Искомая выпуклая оболочка будет находится в стеке после того, как мы ойдем до конца отсортированного массива.

      $p9

      <h5>Оценим асимптотику данного алгоритма.</h5>
      Поиск минимума и построение выпуклой оболочки в стеке (каждая вершина добавляется 1 раз и удаляется не более 1
      раза) являются линейными. Соответственно ключевой фактор - скорость сортировки. Использование quicksort
      сводит искомую асимптотику времени к O(NlogN).
    </p>
  </div>
  <script src="bundle-lesson.js" charset="utf-8"></script>
</body>

</html>